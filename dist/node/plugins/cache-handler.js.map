{"version":3,"sources":["../../../src/plugins/cache-handler.js"],"names":["module","exports","_cachedETags","method","path","eTag","data","status","input","clientOptions","headers","cacheHandler","get","Promise","resolve","cb","request","jqXHR","ref","Error","add"],"mappings":"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","file":"cache-handler.js","sourcesContent":["module.exports = new class CacheHandler {\n  constructor () {\n    this._cachedETags = {}\n  }\n\n  // Default cacheHandler methods\n  get (method, path) {\n    return this._cachedETags[`${method} ${path}`]\n  }\n\n  add (method, path, eTag, data, status) {\n    return this._cachedETags[`${method} ${path}`] = {eTag, data, status}\n  }\n\n  requestMiddlewareAsync (input) {\n    let {clientOptions, method, path} = input\n    if (input.headers == null) { input.headers = {} }\n    let cacheHandler = clientOptions.cacheHandler || this\n    // Send the ETag if re-requesting a URL\n    if (cacheHandler.get(method, path)) {\n      input.headers['If-None-Match'] = cacheHandler.get(method, path).eTag\n    } else {\n      // The browser will sneak in a 'If-Modified-Since' header if the GET has been requested before\n      // but for some reason the cached response does not seem to be available\n      // in the jqXHR object.\n      // So, the first time a URL is requested set this date to 0 so we always get a response the 1st time\n      // a URL is requested.\n      input.headers['If-Modified-Since'] = 'Thu, 01 Jan 1970 00:00:00 GMT'\n    }\n\n    return Promise.resolve(input)\n  }\n\n  responseMiddlewareAsync (input, cb) {\n    let {clientOptions, request, status, jqXHR, data} = input\n    if (!jqXHR) { return Promise.resolve(input) } // The plugins are all used in `octo.parse()` which does not have a jqXHR\n\n    // Since this can be called via `octo.parse`, skip caching when there is no jqXHR\n    if (jqXHR) {\n      let {method, path} = request // This is also not defined when octo.parse is called\n\n      let cacheHandler = clientOptions.cacheHandler || this\n      if (status === 304 || status === 0) {\n        let ref = cacheHandler.get(method, path)\n        if (ref) {\n          var eTag;\n          ({data, status, eTag} = ref)\n          // Set a flag on the object so users know this is a cached response\n          // if (typeof data !== 'string') {\n          //   data.__IS_CACHED = eTag || true\n          // }\n        } else {\n          throw new Error(`ERROR: Bug in Octokat cacheHandler for path '${method} ${path}'. It had an eTag but not the cached response.`)\n        }\n      } else {\n        // Cache the response to reuse later\n        if (method === 'GET' && jqXHR.headers.get('ETag')) {\n          var eTag = jqXHR.headers.get('ETag')\n          cacheHandler.add(method, path, eTag, data, jqXHR.status)\n        }\n      }\n\n      input.data = data\n      input.status = status\n      return Promise.resolve(input)\n    }\n  }\n}()\n"]}